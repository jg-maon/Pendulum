#ifndef DEF_ENEMYBASE_HPP
#define DEF_ENEMYBASE_HPP

#ifndef DEF_CHARAOBJBASE_HPP
#include "charaObjBase.hpp"
#endif

#ifndef DEF_ATTACKBASE_HPP
#include "attackBase.hpp"
#endif

#ifndef DEF_MYMATH_HPP
#include "MyMath.hpp
#endif

#ifndef DEF_NWAYSHOT_H
#include "nWayShot.h"
#endif

#ifndef DEF_NWAYSING_H
#include "nWaySing.h"
#endif

#include <memory>

/*
	@brief		敵基本クラス
	@attention	名前は必ず"E_"から始めること
*/
class IEnemy : public ICharacter
{
protected:
	AttackPtr attack_;							// 攻撃手段
protected:
	
public:
	/*
		@brief	コンストラクタ
		@param	[in]	name	名前("E_"から始める)
		@param	[in]	attack	攻撃用クラスポインタ
		@attention	nameは"E_"から始めること
	*/
	IEnemy(const std::string& name):
		ICharacter(name)
	{}
	/*
		@brief	インターフェース化するための純粋仮想関数
	*/
	virtual ~IEnemy() = 0{}
	/*
		@brief	更新処理
		@return	なし
	*/
	virtual void step() = 0{ __super::step(); }
	/*
		@brief	描画処理
		@return	なし
	*/
	virtual void draw() = 0{}
	/*
		@brief	ダメージ加算
		@param	[in]	dam	ダメージ量
		@return 死亡したか
		@retval	true	死亡
		@retval	false	残存
	*/
	virtual bool ApplyDamage(int dam) = 0{ return true; }

	/*
		@brief	ワールド座標の当たり判定領域の取得
		@return	ワールド座標の当たり判定領域
	*/
	virtual Collisions GetCollisionAreas() const { return __super::GetCollisionAreas(); }

	/*
		@brief	攻撃の当たり判定領域の取得
		@return	攻撃の当たり判定領域
	*/
	virtual Collisions GetAttackCollisions() const {return attack_->GetCollisionAreas();}

	/*
		@brief	攻撃手段情報の格納
		@attension	ifstreamのcurrentPositionに注意
					if (FindChunk(f,"#Attack"))
						LoadAttack(f);
		@param	[in/out]	f	オープン済みファイル
		@return		EOFか
		@retval		true		EOF
		@retval		false		EOFでない
	*/
	bool LoadAttack(std::ifstream& f)
	{
		std::string buf;
		f >> buf;
		if (buf == "NWayShot")
		{
			f >> buf;
			if (buf != "{") return f.eof();
			else
			{
				charabase::CharBase shot_info;
				f >> buf;	// Imgラベル読み飛ばし
				f >> shot_info.resname;

				f >> buf;	// Widthラベル読み飛ばし
				LoadValue(f, obj_, shot_info.size.x);
				f >> buf;	// Heightラベル読み飛ばし
				LoadValue(f, obj_, shot_info.size.y);

				CShot shot(shot_info);
				f >> buf;	// 当たり判定ラベル読み飛ばし
				shot.LoadCollisions(f);
				attack_ = AttackPtr(new CNWayShot(shot));
			}
		}
		else if (buf == "NWaySing")
		{
			f >> buf;
			if (buf != "{") return f.eof();
			else
			{
				charabase::CharBase sing_info;
				f >> buf;	// Imgラベル読み飛ばし
				f >> sing_info.resname;

				f >> buf;	// Widthラベル読み飛ばし
				LoadValue(f, obj_, sing_info.size.x);
				f >> buf;	// Heightラベル読み飛ばし
				LoadValue(f, obj_, sing_info.size.y);

				CSing sing(sing_info);
				f >> buf;	// 当たり判定ラベル読み飛ばし
				sing.LoadCollisions(f);
				attack_ = AttackPtr(new CNWaySing(sing));
			}

		}
		
		return f.eof();
	}

	/*
		@brief	攻撃手段の取得
		@return	攻撃手段
	*/
	const AttackPtr& getAttack() const{ return attack_; }

};
typedef std::shared_ptr<IEnemy> EnemyPtr;

#endif